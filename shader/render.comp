#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_debug_printf : enable
#include "./share.h"
#include "./random.glsl"
#include "./noise.glsl"
#include "./intersection.glsl"

layout(local_size_x = 8, local_size_y = 8) in;
layout(binding = 0, rgba8) uniform image2D outputImage;
layout(binding = 1) uniform sampler3D vdbImage;
//layout(binding = 1, r32f) uniform image3D vdbImage;

float remap(float value, float min1, float max1, float min2, float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

#define linearstep(edge0, edge1, x) min(max(((x) - (edge0)) / ((edge1) - (edge0)), 0.0), 1.0)

const float PI = 3.1415926535;

float sampleDensity(vec3 p)
{
    vec3 uvw = (p - volumeMin.xyz) / volumeSize.xyz;
    float val = texture(vdbImage, uvw).r;
    val = remap(val, remapValue[0], remapValue[1], remapValue[2], remapValue[3]);
    val = clamp(val, 0.0, 1.0);
    return val;
}

vec3 colorRamp2(float value, vec3 color0, vec3 color1) {
    //float t = (value - knot0) / (knot1 - knot0);
    if(value == 0.0) return vec3(0.0);
    return mix(color0, color1, value);
}

vec3 colorRamp5(float value, vec3 color0, vec3 color1, vec3 color2, vec3 color3, vec3 color4) {
    if(value == 0.0) return vec3(0.0);
    if(value < 0.25){
        float t = value * 4.0;
        return mix(color0, color1, t);
    }else if(value < 0.5){
        float t = (value - 0.25) * 4.0;
        return mix(color1, color2, t);
    }else if(value < 0.75){
        float t = (value - 0.5) * 4.0;
        return mix(color1, color2, t);
    }else{
        float t = (value - 0.75) * 4.0;
        return mix(color1, color2, t);
    }
}

float phaseFunction()
{
    return 1.0 / (4.0 * PI);
}

// GLSL cannot include recursive call.
//vec3 computeRadiance(vec3 origin, vec3 direction)
//{
//    const int MAX_DEPTH = 4;
//    vec3 weight = vec3(1.0);
//    for(int depth = 1; depth < MAX_DEPTH; depth++){
//        vec3 transmittance = vec3(1.0);
//        vec3 emission = vec3(0.0);
//        vec3 scatteringCoefficient = vec3(1.0);
//        vec3 nextOrigin = origin;
//        vec3 nextDirection = direction;
//        vec3 inRadiance = computeRadiance(nextOrigin, nextDirection);
//        float ds = 1.0;
//    
//        // Lo = ç T() [Le + ƒÐs() ç fp() Li() dƒÖ] ds
//        vec3 radiance = transmittance * (emission + scatteringCoefficient * phaseFunction() * inRadiance) * ds;
//    }
//    //return radiance;
//}

vec3 computeDirectRadiance(vec3 position, float secondRayTMax, float stepSize, 
                           vec3 sunIntensity, vec3 sunDirection, inout uint seed)
{
    // secondRayTMin is alway minus, so length = secondRayTMax.
    
    //vec3 startPosition = position + sunDirection * max(0.0, tMin);
    float offset = stepSize * rand(seed);
    int maxSteps = int((secondRayTMax - offset) / stepSize);

    float totalDensity = 0.0;
    //int secondMaxSteps = int(secondRayTMax / stepSize);
    vec3 samplePosition = position + sunDirection * offset;

    for(int j = 0; j < maxSteps; j++){
        samplePosition += sunDirection * stepSize;
        //totalDensity += sampleDensity(samplePosition);
        float density = 0.1;
        if(enableNoise == 1){
            density = sampleDensity(samplePosition);
        }
        totalDensity += density;
    }

    // Consider only absorption.
    // Ignore scattering and emission.
    vec3 absorptionCoefficient = (vec3(1.0) - absorption.xyz) * totalDensity;
    vec3 transmittance = exp(-absorptionCoefficient);
    vec3 radiance = transmittance * sunIntensity * stepSize;
    return radiance;
}

vec3 computeTransmittance(float totalDensity)
{
    vec3 absorptionCoefficient = (vec3(1.0) - absorption.xyz) * totalDensity;
    vec3 scatteringCoefficient = vec3(1.0) * totalDensity;
    vec3 extinctionCoefficient = absorptionCoefficient + scatteringCoefficient;
    vec3 transmittance = exp(-extinctionCoefficient);
    return transmittance;
}

vec3 computeColor(vec3 origin, vec3 direction, 
                  vec3 volumeAABBMin, vec3 volumeAABBMax,
                  vec3 sphereCenter, float sphereRadius,
                  vec3 sunIntensity, vec3 sunDirection,
                  inout uint seed)
{
    vec3 radiance = vec3(0.0);
    
    float tMin;
    float tMax;
    bool intersected;
    if(shape == SHAPE_CUBE){
        intersected = intersectAABB(origin, direction, volumeAABBMin, volumeAABBMax, tMin, tMax);
    }else if(shape == SHAPE_SPHERE){
        intersected = intersectSphere(origin, direction, sphereCenter, sphereRadius, tMin, tMax);
    }
    if(intersected){
        // If eye is in the volume area, nearPosition should be origin;
        const vec3 startPosition = origin + direction * max(0.0, tMin);

        float stepSize = 0.1;
        float offset = stepSize * rand(seed);
        vec3 samplePosition = startPosition + direction * offset;
        int maxSteps = int((tMax - max(0.0, tMin) - offset) / stepSize);
        float totalDensity = 0.0;
        for(int i = 0; i < maxSteps; i++){
            samplePosition += direction * stepSize;
            float density = 0.1;
            if(enableNoise == 1){
                density = sampleDensity(samplePosition);
            }

            //float secondRayTMin;
            //float secondRayTMax;
            //if(shape == SHAPE_CUBE){
            //    intersectAABB(samplePosition, sunDirection, volumeAABBMin, volumeAABBMax, 
            //                  secondRayTMin, secondRayTMax);
            //}else if(shape == SHAPE_SPHERE){
            //    intersectSphere(samplePosition, sunDirection, sphereCenter, sphereRadius, 
            //                  secondRayTMin, secondRayTMax);
            //}

//#define SAMPLE_SECOND_RAY
//#ifdef SAMPLE_SECOND_RAY
//            // Consider only absorption.
//            // Ignore scattering and emission.
//            vec3 scatteringCoefficient = vec3(1.0) * density;
//            vec3 transmittance = computeTransmittance(totalDensity);
//            vec3 emission = vec3(0.0);
//            vec3 inRadiance = computeDirectRadiance(samplePosition, secondRayTMax, stepSize, 
//                                                    sunIntensity, sunDirection, seed) * 100.0;
//            
//            // Lo = ç T() [Le + ƒÐs() ç fp() Li() dƒÖ] ds
//            radiance += transmittance * (emission + scatteringCoefficient * phaseFunction() * inRadiance) * stepSize;
//#else
//            //if(gl_GlobalInvocationID.xy == uvec2(resolution / 2.0) && frame == 1){
//            //    debugPrintfEXT("secondRayT: %f %f\n", secondRayTMin, secondRayTMax);
//            //}
//
//            vec3 inRadiance = sunIntensity * exp(-(vec3(1.0) - absorption.xyz) * secondRayTMax * 10);
//            radiance += (1.0 - min(1.0, totalDensity)) * density * inRadiance;
//#endif
            float maxValue = 1.52996;
            radiance += colorRamp5(density / maxValue, 
                vec3(0.00392157, 0.278431, 0.376471),
                vec3(0.0919028, 0.000379446, 0.153744),
                vec3(0.491768, 0.00288083, 0.0911382),
                vec3(0.948677, 0.264162, 0.00023388),
                vec3(0.973729, 0.996282, 0.373522)) * 0.2;
                
            //radiance += colorRamp2(density, 
            //    vec3(1.0, 0.0, 0.0),
            //    vec3(0.0, 0.0, 1.0)) * 0.1;
            totalDensity += density;
        }
    }
    radiance = clamp(radiance, 0.0, 1.0);
    return radiance;
}

void main()
{
    vec2 resolution = vec2(gl_WorkGroupSize.xy * gl_NumWorkGroups.xy);
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / resolution * 2.0 - 1.0;

    vec3 origin    = (invView * vec4(0, 0, 0, 1)).xyz;
    vec3 target    = (invProj * vec4(uv.x, uv.y, 1, 1)).xyz;
    vec3 direction = (invView * vec4(normalize(target), 0)).xyz;

    uvec2 s = pcg2d(ivec2(gl_GlobalInvocationID.xy));
    uint seed = s.x + s.y;

    vec3 sunIntensity = vec3(lightIntensity);
    vec3 sunDirection = normalize(vec3(1.0, -1.5, 0.8));

    float tMin;
    float tMax;
    vec3 sphereCenter = vec3(0.0);
    float sphereRadius = 1.0;

    vec3 color = vec3(0.0);
    uint sampleCount = 8;
    for(int i = 0; i < sampleCount; i++){
        color += computeColor(
            origin, direction, 
            volumeMin.xyz, volumeSize.xyz + volumeMin.xyz,
            sphereCenter, sphereRadius, 
            sunIntensity, sunDirection, 
            seed);
    }
    color /= sampleCount;

    imageStore(outputImage, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1));
}
