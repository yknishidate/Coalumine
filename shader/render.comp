#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_debug_printf : enable
#include "./share.h"
#include "./random.glsl"
#include "./noise.glsl"
#include "./color.glsl"
#include "./intersection.glsl"

layout(local_size_x = 8, local_size_y = 8) in;
layout(binding = 0, rgba32f) uniform image2D baseImage;
layout(binding = 1) uniform sampler3D volumeImage;
layout(binding = 2, rgba32f) uniform image2D bloomImage;
layout(binding = 3, rgba8) uniform image2D finalImage;

float remap(float value, float min1, float max1, float min2, float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

const float PI = 3.1415926535;

float sampleVolume(vec3 p, inout uint seed)
{
    vec3 uvw = p / volumeSize.xyz + 0.5;
    uvw.y = -uvw.y;
    if(enableFlowNoise == 1){
        vec3 scale = vec3(10.0);
        vec3 shift = vec3(0.0);
        float radius = 1.0;
        float quantity = (noise3D(uvw * 10) + 1.0) * 0.02;
        float t = float(frame * flowSpeed);
        vec3 flow = flowNoise(uvw, t, scale, shift, radius) * quantity;
        uvw += flow;
    }
    //uvw += (vec3(rand(seed), rand(seed), rand(seed)) - 0.5) * 0.005;
    float val = texture(volumeImage, uvw).r;
    return val;
}

float phaseFunction()
{
    return 1.0 / (4.0 * PI);
}

vec3 computeDirectRadiance(vec3 position, float secondRayTMax, float stepSize, 
                           vec3 sunIntensity, vec3 sunDirection, inout uint seed)
{
    // secondRayTMin is alway minus, so length = secondRayTMax.
    float offset = stepSize * rand(seed);
    int maxSteps = int((secondRayTMax - offset) / stepSize);

    float totalDensity = 0.0;
    vec3 samplePosition = position + sunDirection * offset;

    for(int j = 0; j < maxSteps; j++){
        samplePosition += sunDirection * stepSize;
        float density = 0.1;
        if(enableNoise == 1){
            density = sampleVolume(samplePosition, seed);
        }
        totalDensity += density;
    }

    // Consider only absorption.
    // Ignore scattering and emission.
    vec3 absorptionCoefficient = (vec3(1.0) - absorption.xyz) * totalDensity;
    vec3 transmittance = exp(-absorptionCoefficient);
    vec3 radiance = transmittance * sunIntensity * stepSize;
    return radiance;
}

vec3 computeTransmittance(float totalDensity)
{
    vec3 absorptionCoefficient = (vec3(1.0) - absorption.xyz) * totalDensity;
    vec3 scatteringCoefficient = vec3(1.0) * totalDensity;
    vec3 extinctionCoefficient = absorptionCoefficient + scatteringCoefficient;
    vec3 transmittance = exp(-extinctionCoefficient);
    return transmittance;
}

vec3 renderNebula(vec3 origin, vec3 direction, 
                  vec3 volumeAABBMin, vec3 volumeAABBMax,
                  inout uint seed)
{
    vec3 radiance = vec3(0.0);
    
    float tMin;
    float tMax;
    bool intersected;
    intersected = intersectAABB(origin, direction, volumeAABBMin, volumeAABBMax, tMin, tMax);
    if(intersected){
        // If eye is in the volume area, nearPosition should be origin;
        const vec3 startPosition = origin + direction * max(0.0, tMin);

        float stepSize = 0.1;
        float offset = stepSize * rand(seed);
        vec3 samplePosition = startPosition + direction * offset;
        int maxSteps = int((tMax - max(0.0, tMin) - offset) / stepSize);
        float totalDensity = 0.0;
        for(int i = 0; i < maxSteps; i++){
            samplePosition += direction * stepSize;
            float value = 0.1;
            if(enableNoise == 1){
                value = sampleVolume(samplePosition, seed);
            }

            if(value > 0.0){
                value = remap(value, remapValue[0], remapValue[1], remapValue[2], remapValue[3]);
                
                vec3 emission = colorRamp5(value,
                    vec3(0.0919028, 0.000379446, 0.153744),
                    vec3(0.00392157, 0.278431, 0.376471),
                    vec3(0.491768, 0.00288083, 0.0911382),
                    vec3(0.948677, 0.264162, 0.00023388),
                    vec3(0.973729, 0.996282, 0.373522)) * (3.0 * stepSize);
                
                radiance += emission;

                totalDensity += 0.1;
            }
        }
    }
    radiance = clamp(radiance, 0.0, 1.0);
    return radiance;
}

void main_base()
{
    vec2 resolution = vec2(gl_WorkGroupSize.xy * gl_NumWorkGroups.xy);
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / resolution * 2.0 - 1.0;

    vec3 origin    = (invView * vec4(0, 0, 0, 1)).xyz;
    vec3 target    = (invProj * vec4(uv.x, uv.y, 1, 1)).xyz;
    vec3 direction = (invView * vec4(normalize(target), 0)).xyz;

    uvec2 s = pcg2d(ivec2(gl_GlobalInvocationID.xy));
    uint seed = s.x + s.y;

    vec3 color = vec3(0.0);
    uint sampleCount = 4;
    for(int i = 0; i < sampleCount; i++){
        color += renderNebula(origin, direction, 
                              -volumeSize.xyz * 0.5, volumeSize.xyz * 0.5,
                              seed);
    }
    color /= sampleCount;

    //float luminace = computeLuminance(color * lightIntensity);
    float luminace = computeLuminance(color);
    vec3 bloomColor = color * max(vec3(0.0), luminace - bloomThreshold);
    imageStore(bloomImage, ivec2(gl_GlobalInvocationID.xy), vec4(bloomColor, 1));
    imageStore(baseImage, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1));
}

float kernel[5][5] = float[][](
    float[](0.003, 0.013, 0.022, 0.013, 0.003),
    float[](0.013, 0.059, 0.097, 0.059, 0.013),
    float[](0.022, 0.097, 0.159, 0.097, 0.022),
    float[](0.013, 0.059, 0.097, 0.059, 0.013),
    float[](0.003, 0.013, 0.022, 0.013, 0.003)
);

vec3 blur(ivec2 st)
{
    uvec2 s = pcg2d(ivec2(gl_GlobalInvocationID.xy));
    uint seed = s.x + s.y;

    vec3 bluredColor = vec3(0.0);
    int kernelSize = 5;
    int halfKernelSize = kernelSize / 2;
    for (int i = -halfKernelSize; i <= halfKernelSize; i++) {
        for (int j = -halfKernelSize; j <= halfKernelSize; j++) {
            int scale = blurSize + int(rand(seed) * (blurSize * 0.25));
            vec3 currentColor = imageLoad(bloomImage, st + ivec2(i, j) * scale).rgb;
            bluredColor += currentColor * kernel[j + halfKernelSize][i + halfKernelSize];
            //bluredColor += currentColor / (kernelSize * kernelSize);
        }
    }
    return bluredColor;
}

void main_blur()
{
    vec2 resolution = vec2(gl_WorkGroupSize.xy * gl_NumWorkGroups.xy);
    ivec2 st = ivec2(gl_GlobalInvocationID.xy);

    vec3 bloomColor = blur(st);
    imageStore(bloomImage, st, vec4(bloomColor, 1.0));
}

void main_composite()
{
    ivec2 st = ivec2(gl_GlobalInvocationID.xy);

    vec3 baseColor = imageLoad(baseImage, st).rgb;
    vec3 bloomColor = imageLoad(bloomImage, st).rgb;
    
    vec3 color = baseColor;
    if(enableBloom == 1){
        color += bloomColor * bloomIntensity;
    }
    
    color = saturate(color, 1.1);
    //color *= 1.5;

    //color = toneMapping(color, lightIntensity);
    //color = toneMappingACESFilmic(color, lightIntensity);
    //color = pow(color, vec3(1.0/2.2));

    imageStore(finalImage, st, vec4(color, 1.0));
}
