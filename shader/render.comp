#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_debug_printf : enable
#include "./share.h"
#include "./random.glsl"
#include "./noise.glsl"
#include "./intersection.glsl"

layout(local_size_x = 8, local_size_y = 8) in;
layout(binding = 0, rgba32f) uniform image2D baseImage;
layout(binding = 1) uniform sampler3D volumeImage;
layout(binding = 2, rgba32f) uniform image2D bloomImage;
layout(binding = 3, rgba8) uniform image2D finalImage;

float remap(float value, float min1, float max1, float min2, float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

#define linearstep(edge0, edge1, x) min(max(((x) - (edge0)) / ((edge1) - (edge0)), 0.0), 1.0)

const float PI = 3.1415926535;

float sampleVolume(vec3 p)
{
    vec3 uvw = p / volumeSize.xyz + 0.5;
    uvw.y = -uvw.y;
    if(enableFlowNoise == 1){
        vec3 scale = vec3(10.0);
        vec3 shift = vec3(0.0);
        float radius = 10.1;
        float quantity = smoothstep(0.0, 0.2, noise3D(uvw * 10)) * 0.1;
        //float quantity = 0.1;
        float t = float(frame * flowSpeed);
        vec3 flow = flowNoise(uvw, t, scale, shift, radius) * quantity;
        uvw += flow;
    }
    float val = texture(volumeImage, uvw).r;
    return val;
}

vec3 colorRamp2(float value, vec3 color0, vec3 color1) {
    if(value == 0.0) return vec3(0.0);
    return mix(color0, color1, value);
}

vec3 colorRamp5(float value, vec3 color0, vec3 color1, vec3 color2, vec3 color3, vec3 color4) {
    if(value == 0.0) return vec3(0.0);
    float knot0 = 0.0;
    float knot1 = 0.15;
    float knot2 = 0.32;
    float knot3 = 0.7;
    float knot4 = 1.0;
    if(value < knot0){
        return color0;
    }else if(value < knot1){
        float t = (value - knot0) * (knot1 - knot0);
        return mix(color0, color1, t);
    }else if(value < knot2){
        float t = (value - knot1) * (knot2 - knot1);
        return mix(color1, color2, t);
    }else if(value < knot3){
        float t = (value - knot2) * (knot3 - knot2);
        return mix(color2, color3, t);
    }else if(value < knot4){
        float t = (value - knot3) * (knot4 - knot3);
        return mix(color3, color4, t);
    }else{
        return color4;
    }
}

vec3 colorRamp6(float value, vec3 color0, vec3 color1, vec3 color2, vec3 color3, vec3 color4, vec3 color5) {
    if(value == 0.0) return vec3(0.0);
    float knot0 = 0.0;
    float knot1 = 0.2;
    float knot2 = 0.4;
    float knot3 = 0.5;
    float knot4 = 0.8;
    float knot5 = 1.0;
    if(value < knot0){
        return color0;
    }else if(value < knot1){
        float t = (value - knot0) * (knot1 - knot0);
        return mix(color0, color1, t);
    }else if(value < knot2){
        float t = (value - knot1) * (knot2 - knot1);
        return mix(color1, color2, t);
    }else if(value < knot3){
        float t = (value - knot2) * (knot3 - knot2);
        return mix(color2, color3, t);
    }else if(value < knot4){
        float t = (value - knot3) * (knot4 - knot3);
        return mix(color3, color4, t);
    }else if(value < knot5){
        float t = (value - knot4) * (knot5 - knot4);
        return mix(color4, color5, t);
    }else{
        return color5;
    }
}

vec3 colorRamp3(float value, vec3 color0, vec3 color1, vec3 color2) {
    if(value == 0.0) return vec3(0.0);
    if(value < 0.5){
        float t = value * 2.0;
        return mix(color0, color1, t);
    }else{
        float t = (value - 0.5) * 2.0;
        return mix(color1, color2, t);
    }
}

float phaseFunction()
{
    return 1.0 / (4.0 * PI);
}

vec3 computeDirectRadiance(vec3 position, float secondRayTMax, float stepSize, 
                           vec3 sunIntensity, vec3 sunDirection, inout uint seed)
{
    // secondRayTMin is alway minus, so length = secondRayTMax.
    
    //vec3 startPosition = position + sunDirection * max(0.0, tMin);
    float offset = stepSize * rand(seed);
    int maxSteps = int((secondRayTMax - offset) / stepSize);

    float totalDensity = 0.0;
    //int secondMaxSteps = int(secondRayTMax / stepSize);
    vec3 samplePosition = position + sunDirection * offset;

    for(int j = 0; j < maxSteps; j++){
        samplePosition += sunDirection * stepSize;
        //totalDensity += sampleVolume(samplePosition);
        float density = 0.1;
        if(enableNoise == 1){
            density = sampleVolume(samplePosition);
        }
        totalDensity += density;
    }

    // Consider only absorption.
    // Ignore scattering and emission.
    vec3 absorptionCoefficient = (vec3(1.0) - absorption.xyz) * totalDensity;
    vec3 transmittance = exp(-absorptionCoefficient);
    vec3 radiance = transmittance * sunIntensity * stepSize;
    return radiance;
}

vec3 computeTransmittance(float totalDensity)
{
    vec3 absorptionCoefficient = (vec3(1.0) - absorption.xyz) * totalDensity;
    vec3 scatteringCoefficient = vec3(1.0) * totalDensity;
    vec3 extinctionCoefficient = absorptionCoefficient + scatteringCoefficient;
    vec3 transmittance = exp(-extinctionCoefficient);
    return transmittance;
}

vec3 computeColor(vec3 origin, vec3 direction, 
                  vec3 volumeAABBMin, vec3 volumeAABBMax,
                  vec3 sphereCenter, float sphereRadius,
                  vec3 sunIntensity, vec3 sunDirection,
                  inout uint seed)
{
    vec3 radiance = vec3(0.0);
    
    float tMin;
    float tMax;
    bool intersected;
    intersected = intersectAABB(origin, direction, volumeAABBMin, volumeAABBMax, tMin, tMax);
    if(intersected){
        // If eye is in the volume area, nearPosition should be origin;
        const vec3 startPosition = origin + direction * max(0.0, tMin);

        float stepSize = 0.1;
        float offset = stepSize * rand(seed);
        vec3 samplePosition = startPosition + direction * offset;
        int maxSteps = int((tMax - max(0.0, tMin) - offset) / stepSize);
        float totalDensity = 0.0;
        for(int i = 0; i < maxSteps; i++){
            samplePosition += direction * stepSize;
            float value = 0.1;
            if(enableNoise == 1){
                value = sampleVolume(samplePosition);
            }

            if(value > 0.0){
                value = remap(value, remapValue[0], remapValue[1], remapValue[2], remapValue[3]);
                
                vec3 emission = colorRamp5(value,
                    vec3(0.0919028, 0.000379446, 0.153744),
                    vec3(0.00392157, 0.278431, 0.376471),
                    vec3(0.491768, 0.00288083, 0.0911382),
                    vec3(0.948677, 0.264162, 0.00023388),
                    vec3(0.973729, 0.996282, 0.373522)) * (3.0 * stepSize);
                
                radiance += emission;

                totalDensity += 0.1;
            }
        }
    }
    radiance = clamp(radiance, 0.0, 1.0);
    return radiance;
}

float computeLuminance(vec3 color)
{
    // RGB to YUV weights for luminance calculation
    const vec3 W = vec3(0.2126, 0.7152, 0.0722);
    return dot(color, W);
}

void main_base()
{
    vec2 resolution = vec2(gl_WorkGroupSize.xy * gl_NumWorkGroups.xy);
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / resolution * 2.0 - 1.0;

    vec3 origin    = (invView * vec4(0, 0, 0, 1)).xyz;
    vec3 target    = (invProj * vec4(uv.x, uv.y, 1, 1)).xyz;
    vec3 direction = (invView * vec4(normalize(target), 0)).xyz;

    uvec2 s = pcg2d(ivec2(gl_GlobalInvocationID.xy));
    uint seed = s.x + s.y;

    vec3 sunIntensity = vec3(lightIntensity);
    vec3 sunDirection = normalize(vec3(1.0, -1.5, 0.8));

    float tMin;
    float tMax;
    vec3 sphereCenter = vec3(0.0);
    float sphereRadius = 1.0;

    vec3 color = vec3(0.0);
    uint sampleCount = 8;
    for(int i = 0; i < sampleCount; i++){
        color += computeColor(
            origin, direction, 
            -volumeSize.xyz * 0.5, volumeSize.xyz * 0.5,
            sphereCenter, sphereRadius, 
            sunIntensity, sunDirection, 
            seed);
    }
    color /= sampleCount;

    //float luminace = computeLuminance(color * lightIntensity);
    float luminace = computeLuminance(color);
    vec3 bloomColor = color * max(vec3(0.0), luminace - bloomThreshold);
    imageStore(bloomImage, ivec2(gl_GlobalInvocationID.xy), vec4(bloomColor, 1));
    imageStore(baseImage, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1));
}

float kernel[5][5] = float[][](
    float[](0.003, 0.013, 0.022, 0.013, 0.003),
    float[](0.013, 0.059, 0.097, 0.059, 0.013),
    float[](0.022, 0.097, 0.159, 0.097, 0.022),
    float[](0.013, 0.059, 0.097, 0.059, 0.013),
    float[](0.003, 0.013, 0.022, 0.013, 0.003)
);

vec3 blur(ivec2 st)
{
    uvec2 s = pcg2d(ivec2(gl_GlobalInvocationID.xy));
    uint seed = s.x + s.y;

    vec3 bluredColor = vec3(0.0);
    int kernelSize = 5;
    int halfKernelSize = kernelSize / 2;
    for (int i = -halfKernelSize; i <= halfKernelSize; i++) {
        for (int j = -halfKernelSize; j <= halfKernelSize; j++) {
            int scale = blurSize + int(rand(seed) * (blurSize * 0.25));
            vec3 currentColor = imageLoad(bloomImage, st + ivec2(i, j) * scale).rgb;
            bluredColor += currentColor * kernel[j + halfKernelSize][i + halfKernelSize];
            //bluredColor += currentColor / (kernelSize * kernelSize);
        }
    }
    return bluredColor;
}

void main_blur()
{
    vec2 resolution = vec2(gl_WorkGroupSize.xy * gl_NumWorkGroups.xy);
    ivec2 st = ivec2(gl_GlobalInvocationID.xy);

    vec3 bloomColor = blur(st);
    imageStore(bloomImage, st, vec4(bloomColor, 1.0));
}

vec3 toneMapping(vec3 color, float exposure)
{
    color = vec3(1.0) - exp(-color * exposure);
    return color;
}

void main_composite()
{
    ivec2 st = ivec2(gl_GlobalInvocationID.xy);

    vec3 baseColor = imageLoad(baseImage, st).rgb;
    vec3 bloomColor = imageLoad(bloomImage, st).rgb;
    
    vec3 color = baseColor;
    if(enableBloom == 1){
        color += bloomColor * bloomIntensity;
    }
    
    //color = toneMapping(color, lightIntensity);
    //color = pow(color, vec3(1.0/2.2));

    imageStore(finalImage, st, vec4(color, 1.0));
}
