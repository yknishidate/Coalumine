#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_debug_printf : enable
#include "./share.h"
#include "./random.glsl"
#include "./perlin.glsl"
#include "./intersection.glsl"

layout(local_size_x = 8, local_size_y = 8) in;
layout(binding = 0, rgba8) uniform image2D outputImage;

float remap(float x, float in0, float in1, float out0, float out1) {
    return out0 + (out1 - out0) * (x - in0) / (in1 - in0);
}

float sampleDensity(vec3 p)
{
    float val0 = noise3D(p * noiseFreq0);
    float val1 = noise3D(p * noiseFreq1);
    val0 = max(0.0, val0);
    val1 = max(0.0, val1);
    float val = val0 * val1;
    val = remap(val, remapValue[0], remapValue[1], remapValue[2], remapValue[3]);
    val = clamp(val, 0.0, 1.0);
    return val;
}

vec3 computeRadiance(vec3 origin, vec3 direction, 
                     vec3 volumeAABBMin, vec3 volumeAABBMax,
                     vec3 sphereCenter, float sphereRadius,
                     vec3 sunIntensity, vec3 sunDirection,
                     inout uint seed)
{
    vec3 radiance = vec3(0.0);
    
    float tMin;
    float tMax;
    bool intersected;
    if(shape == SHAPE_CUBE){
        intersected = intersectAABB(origin, direction, volumeAABBMin, volumeAABBMax, tMin, tMax);
    }else if(shape == SHAPE_SPHERE){
        intersected = intersectSphere(origin, direction, sphereCenter, sphereRadius, tMin, tMax);
    }
    if(intersected){
        vec3 nearPosition = origin + direction * tMin;
        vec3 farPosition = origin + direction * tMax;

        float stepSize = 0.1;
        float offset = stepSize * rand(seed);
        vec3 samplePosition = nearPosition + direction * offset;
        int maxSteps = int((tMax - tMin - offset) / stepSize);
        float totalDensity = 0.0;
        for(int i = 0; i < maxSteps; i++){
            samplePosition += direction * stepSize;
            float density = 0.1;
            if(enableNoise == 1){
                density = sampleDensity(samplePosition);
            }

            float secondRayTMin;
            float secondRayTMax;
            if(shape == SHAPE_CUBE){
                intersectAABB(samplePosition, sunDirection, volumeAABBMin, volumeAABBMax, 
                              secondRayTMin, secondRayTMax);
            }else if(shape == SHAPE_SPHERE){
                intersectSphere(samplePosition, sunDirection, sphereCenter, sphereRadius, 
                              secondRayTMin, secondRayTMax);
            }

            //if(gl_GlobalInvocationID.xy == uvec2(resolution / 2.0) && frame == 1){
            //    debugPrintfEXT("secondRayT: %f %f\n", secondRayTMin, secondRayTMax);
            //}

            vec3 inRadiance = sunIntensity * exp(-(vec3(1.0) - absorption.xyz) * secondRayTMax * 10);
            radiance += (1.0 - min(1.0, totalDensity)) * density * inRadiance;
            totalDensity += density;
        }
    }
    radiance = clamp(radiance, 0.0, 1.0);
    return radiance;
}

void main()
{
    vec2 resolution = vec2(gl_WorkGroupSize.xy * gl_NumWorkGroups.xy);
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / resolution * 2.0 - 1.0;

    vec3 origin    = (invView * vec4(0, 0, 0, 1)).xyz;
    vec3 target    = (invProj * vec4(uv.x, uv.y, 1, 1)).xyz;
    vec3 direction = (invView * vec4(normalize(target), 0)).xyz;

    uvec2 s = pcg2d(ivec2(gl_GlobalInvocationID.xy));
    uint seed = s.x + s.y;

    vec3 sunIntensity = vec3(lightIntensity);
    vec3 sunDirection = normalize(vec3(1.0, -1.5, 0.8));

    float tMin;
    float tMax;
    vec3 volumeAABBMin = vec3(-1.0);
    vec3 volumeAABBMax = vec3(1.0);
    vec3 sphereCenter = vec3(0.0);
    float sphereRadius = 1.0;

    vec3 radiance = vec3(0.0);
    uint sampleCount = 8;
    for(int i = 0; i < sampleCount; i++){
        radiance += computeRadiance(
            origin, direction, 
            volumeAABBMin, volumeAABBMax,
            sphereCenter, sphereRadius, 
            sunIntensity, sunDirection, 
            seed);
    }
    radiance /= sampleCount;

    imageStore(outputImage, ivec2(gl_GlobalInvocationID.xy), vec4(radiance, 1));
}
